rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function getUserTenant(userId) {
      return get(/databases/$(database)/documents/userTenants/$(userId));
    }
    
    function userBelongsToTenant(userId, tenantId) {
      let userTenant = getUserTenant(userId);
      return userTenant != null && 
             userTenant.data != null &&
             tenantId in userTenant.data.tenants;
    }
    
    function hasRole(userId, tenantId, allowedRoles) {
      let userTenant = getUserTenant(userId);
      return userTenant != null && 
             userTenant.data != null &&
             tenantId in userTenant.data.tenants &&
             userTenant.data.tenants[tenantId].role in allowedRoles;
    }
    
    function canManageTenant(userId, tenantId) {
      return hasRole(userId, tenantId, ['owner', 'admin']);
    }
    
    function canEditData(userId, tenantId) {
      return hasRole(userId, tenantId, ['owner', 'admin', 'manager']);
    }
    
    function isOwner(userId, tenantId) {
      return hasRole(userId, tenantId, ['owner']);
    }
    
    // Users collection - users can manage their own profile
    match /users/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // UserTenants collection - users can manage their own tenant relationships
    match /userTenants/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // Tenants collection - tenant members can read, owners/admins can write
    match /tenants/{tenantId} {
      allow read: if isAuthenticated() && userBelongsToTenant(request.auth.uid, tenantId);
      allow create: if isAuthenticated(); // Anyone can create a tenant
      allow update: if isAuthenticated() && canManageTenant(request.auth.uid, tenantId);
      allow delete: if isAuthenticated() && isOwner(request.auth.uid, tenantId);
    }
    
    // Invite codes lookup collection (public read for accepting invites)
    match /inviteCodes/{code} {
      allow read: if true; // Anyone can look up an invite code
      allow create: if isAuthenticated() && 
                       userBelongsToTenant(request.auth.uid, request.resource.data.tenantId) &&
                       canEditData(request.auth.uid, request.resource.data.tenantId);
      allow update: if false; // Invite codes should never be updated
      allow delete: if isAuthenticated() && 
                       userBelongsToTenant(request.auth.uid, resource.data.tenantId) &&
                       canManageTenant(request.auth.uid, resource.data.tenantId);
    }
    
    // Tenant invites collection
    match /tenants/{tenantId}/invites/{inviteId} {
      // Allow read if user belongs to tenant OR if they are the invited email
      allow read: if isAuthenticated() && 
                     (userBelongsToTenant(request.auth.uid, tenantId) || 
                      (resource != null && resource.data.recipientEmail == request.auth.token.email));
      
      // Allow create if user can edit data in the tenant
      allow create: if isAuthenticated() && 
                       userBelongsToTenant(request.auth.uid, tenantId) &&
                       canEditData(request.auth.uid, tenantId);
      
      // Allow update if user can manage tenant OR if accepting the invite
      allow update: if isAuthenticated() && 
                       (canManageTenant(request.auth.uid, tenantId) ||
                        (resource.data.recipientEmail == request.auth.token.email &&
                         request.resource.data.status == 'accepted'));
      
      // Allow delete if user can manage tenant
      allow delete: if isAuthenticated() && 
                       canManageTenant(request.auth.uid, tenantId);
    }
    
    // Task-specific rules with assignment checking
    match /tenants/{tenantId}/tasks/{taskId} {
      // Anyone in tenant can read tasks
      allow read: if isAuthenticated() && 
                     userBelongsToTenant(request.auth.uid, tenantId);
      
      // Only assigned users or managers can update
      allow update: if isAuthenticated() && 
                       userBelongsToTenant(request.auth.uid, tenantId) &&
                       (request.auth.uid in resource.data.assignedTo ||
                        hasRole(request.auth.uid, tenantId, ['owner', 'admin', 'manager']));
      
      // Managers and above can create/delete
      allow create, delete: if isAuthenticated() && 
                               hasRole(request.auth.uid, tenantId, ['owner', 'admin', 'manager']);
    }
    
    // Client-specific rules with optional team member creation
    match /tenants/{tenantId}/clients/{clientId} {
      // All tenant members can read
      allow read: if isAuthenticated() && 
                     userBelongsToTenant(request.auth.uid, tenantId);
      
      // Team members can create if feature is enabled
      allow create: if isAuthenticated() && 
                       userBelongsToTenant(request.auth.uid, tenantId) &&
                       (hasRole(request.auth.uid, tenantId, ['owner', 'admin', 'manager']) ||
                        get(/databases/$(database)/documents/tenants/$(tenantId)).data.settings.allowTeamMemberCreateClients == true);
      
      // Only managers and above can update/delete
      allow update, delete: if isAuthenticated() && 
                               hasRole(request.auth.uid, tenantId, ['owner', 'admin', 'manager']);
    }
    
    // Settings protection - separate from tenant document
    match /tenants/{tenantId}/settings/{document} {
      // Only owners and admins can read settings
      allow read: if isAuthenticated() && 
                     hasRole(request.auth.uid, tenantId, ['owner', 'admin']);
      
      // Only owners can write settings
      allow write: if isAuthenticated() && 
                      hasRole(request.auth.uid, tenantId, ['owner']);
    }
    
    // Financial data protection
    match /tenants/{tenantId}/invoices/{invoiceId} {
      // Managers and above can read
      allow read: if isAuthenticated() && 
                     hasRole(request.auth.uid, tenantId, ['owner', 'admin', 'manager']);
      
      // Only admins and owners can create/update
      allow create, update: if isAuthenticated() && 
                               hasRole(request.auth.uid, tenantId, ['owner', 'admin']);
      
      // Only owners can delete
      allow delete: if isAuthenticated() && 
                       hasRole(request.auth.uid, tenantId, ['owner']);
    }
    
    // Bulk invite sessions
    match /tenants/{tenantId}/bulkSessions/{sessionId} {
      allow read: if isAuthenticated() && 
                     userBelongsToTenant(request.auth.uid, tenantId);
      allow create: if isAuthenticated() && 
                       userBelongsToTenant(request.auth.uid, tenantId) &&
                       canEditData(request.auth.uid, tenantId);
      allow update, delete: if false; // Sessions are immutable
    }
    
    // Pending approvals collection (for team member suggestions)
    match /tenants/{tenantId}/pendingApprovals/{inviteId} {
      allow read: if isAuthenticated() && 
                     userBelongsToTenant(request.auth.uid, tenantId);
      allow create: if isAuthenticated() && 
                       userBelongsToTenant(request.auth.uid, tenantId);
      allow update, delete: if isAuthenticated() && 
                               canManageTenant(request.auth.uid, tenantId);
    }
    
    // Default tenant-scoped collections
    match /tenants/{tenantId}/{collection}/{document} {
      allow read: if isAuthenticated() && userBelongsToTenant(request.auth.uid, tenantId);
      allow create, update: if isAuthenticated() && canEditData(request.auth.uid, tenantId);
      allow delete: if isAuthenticated() && canManageTenant(request.auth.uid, tenantId);
      
      // Nested collections
      match /{subcollection}/{subdocument=**} {
        allow read: if isAuthenticated() && userBelongsToTenant(request.auth.uid, tenantId);
        allow create, update: if isAuthenticated() && canEditData(request.auth.uid, tenantId);
        allow delete: if isAuthenticated() && canManageTenant(request.auth.uid, tenantId);
      }
    }
  }
}